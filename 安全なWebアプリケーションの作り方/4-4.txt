■SQLの呼び出しに伴う脆弱性
攻撃者が利用者の介在無しに攻撃を行うことができる。(能動的攻撃)
SQLの呼び出しに不備があると、以下の様な事象が発生しうる。
1.DBの情報が外部から盗まれる。
2.内容が不正に書き換えられる。
3.認証が回避される。
4.DB上のファイル、プログラムの読み出し/書き込み/実行が行われる。

★攻撃例1
GETパラメータを受け取り、検索するSQLを想定する。
今回は、SQLのエラーを発生させ、サーバ側の設定により
エラーの詳細からDBの一部の情報が漏洩している例である。

☆正常なリクエストURL
http://example.jp/44/44-001.php?author=Shakespeare
☆異常なリクエストURL
http://example.jp/44/44-001.php?author='+and+cast((select+id||':'||pwd+from+users+offset+0+limit+1)+as+integer)>1--

★攻撃例2
UNION SELECTを用いることで本来取得できない情報を取得している。
http://example.jp/44/44-001.php?author=author='+union+select+id,pwd,name,addr,null,null,null+from+users--

★SQLインジェクションによる認証回避
input欄に入力するSQLにより、SELECT文のWHERE句が常に成立する事象が発生する。
以下をパスワード入力欄に入力する。
' or 'a'='a
実行されるSQLは以下となる。
SELECT * FROM users WHERE id = 'yamada' and pwd = '' OR 'a'='a'

★SQLインジェクションによる不正なデータ書き換え
検索のSQLが中断され、続くUPDATE文が有効となる事象が発生する。
http://example.jp/44/44-001.php?author=';update+books+set+title%3D'<i>cracked!</i>'+where+id%3d'1001'--
実行されるSQLは以下となる。
--を入力することで、以降のSQLは向こうとなるため、ORDER BYは実行されない。
SELECT * FROM books WHERE author = '';
update books set title='<i>cracked!</i>' where id='1001' --'ORDER BY id

★その他の攻撃
OSコマンドの実行
ファイルの読み出し
ファイルの書き出し
HTTPリクエストによる他のサーバーへの攻撃
以下のリクエストを送信することで、/etc/passwdファイルがtableファイルにコピーされる。
http://example.jp/44/44-001.php?author=';copy+books(title)+from+'/etc/passwd'--
これはPostgreSQLに用意されているcopyコマンドを利用したものであり、
OS上に存在するファイルを任意のテーブルに読み込む構文である。

■DBの脆弱性の原因とは
通常、DBで扱うデータ型は数値型と文字型が大半を占める。
それらのリテラルの扱いが脆弱性の発生する原因である。
★文字に対する脆弱性
SQLでは文字をシングルクォートで囲む。
シングルクォートによるエスケープと呼ぶ。
この処理がなされていない場合、任意のSQLが実行される可能性を含む。
以下のSQLは脆弱性を含む構文であり、O'Reillyという文字列を入力した場合、
有効な構文はauthor='O'までとなり、Reilly'は構文エラーとなる。
SELECT * FROM books WHERE author='O'Reilly'

★数値に対する脆弱性
数値はシングルクォートで囲まない。
そこで、以下のSQL文には脆弱性が含まれる。
SELECT * FROM employees WHERE age < $age

数値を扱う場合には数値以外の文字が来た段階でSQLは一旦終了する。
$ageに以下の文字列を挿入することで任意のSQLが実行されてしまう脆弱性を含む。
SELECT文が終了し、後続のDELETE文が実行されている。
1;DELETE FROM employees

☆数値に対する対策
1.プレースホルダーを利用する。
2.アプリケーション側でチェックを行い、数値以外の値が挿入されないようにする。
2.のパターンでは対応箇所が多くなるので1.のパターンでの対処を推奨する。

☆プレースホルダーとは
以下にプレースホルダーを含むSQLの例を記載する。
SQL文中の?がプレースホルダーと呼ばれる記述となる。
変数や式等、変化する可能性のある場所に指定する。
プレースホルダーに値を割り当てることをバインドと呼ぶ。
SELECT * FROM books WHERE author = ? ORDER BY id

☆プレースホルダーの安全性
プレースホルダーには以下の2種類に分別される。
WebアプリケーションサーバとDBサーバの2つのやり取りを考える。
SQLのコンパイルはDBサーバで実行される。
1.静的プレースホルダー
  →1.プレースホルダー付きのSQLをDBサーバが受け取る。
   2.1.で取得したSQLをDBサーバがコンパイルする。
   　　これにより、SQL文への値の割当のみ可能となり、SQLの改ざんが不可となる。
   3.Webサーバはプレースホルダーに挿入する値(本、名前等の外部入力データ)をDBサーバへ送信する。
   4.2.でコンパイルしたSQL文に3.で受け取った値をDBサーバがバインドする。
   5.実行結果をWebアプリケーションサーバに返す。
   DBサーバ側で値をバインドする。
   DBサーバ側で既にコンパイルしたSQLに対し値のバインドを行うので、SQL文自体の変更が不可となる。
   これにより、安全に値を扱うことができる。
2.動的プレースホルダー
  →1.Webアプリケーションサーバのライブラリ内で値をバインドする。
   2.バインドした値を含むSQLをDBサーバへ送信する。
   3.DBサーバはSQL文をコンパイルし、実行、結果をWebサーバへ返却する。
   Webアプリケーションサーバ側で値のバインドを行う。
   ライブラリにバグが無ければ正常にデータは処理される。
1,2のどちらの手法によってもSQLインジェクションは防止できるが、原理的に不可能である点を考慮し、
1.の静的プレースホルダーを利用することを推奨。

☆検索条件が変化する場合の対処
検索の値/文字だけでなく、条件そのものが変化する場合は、
プレースホルダーを含む検索条件を文字列として連結し、SQL文を構築する。
$sql = 'SELECT id, title, author ,publisher, date, price FROM books';
if($title !== '')//titleに対する条件を付与
{
	$conditions[] = "title LIKE ? ESCAPE '#'";
	$ph_tyle[] = 'text';
	$php_value[] = escape_wildcard($title);
}
if($id !== '')//idに対する条件を付与
{
	$conditions[] = "price <= ?";
	$ph_tyle[] = 'integer';
	$php_value[] = $price;
}

☆列でソートを実施する場合
条件を付与し、列でソートを実施する場合を考える。
SELECT * FROM books ORDER BY $row

そこで、以下の構文をソート条件として実行する。
cast ((select id||':'pwd FROM users limit 1) as integer)

$rowが展開されると以下の構文となる。
SELECT * FROM books ORDER BY cast ((select id||':'pwd FROM users limit 1) as integer)

この構文では副問い合わせが実行され、本来のSQLは構文エラーとなる。
副問い合わせで実施した内容により、idとpassが漏洩する。

■SQLインジェクションに対する保険的対策
プレースホルダーを利用したSQLの構築を前提とするが、ミドルウェア等の
脆弱性が存在する場合に、被害を減少させる事を目的として対策を二重に行う。
1.エラーメッセージの抑制
2.入力値の妥当性検証
3.DBの権限設定

★1.エラーメッセージの抑制について
SQLインジェクションの手法の一つにすく問い合わせを利用したSQLの構文エラーを意図的に発生させ、
構文エラーと共にデータを画面に表示させる方法がある。
これは、詳細なエラー内容を画面に表示する設定が成されている為である。
本来、本番運用している画面に対してはエラー内容はエラーログに出力する方法が正しく、
画面に表示してはならない。
以下の設定により、詳細なエラー内容を表示しないようにする。
☆php.iniの場合
display_errors = Off

★2.入力値の妥当性検証
入力値の検証を実施することで不必要な記号等の入力を防止する。
プレースホルダーを利用していない場合でもSQLインジェクションが防止できる場合もある。
例えば電話番号の入力欄では("<等の記号は不必要であるので、
チェック時に無効とする等の例が考えられる。
ただし、(や'等を許容する仕様である場合には抜本的な解決とはならないため、
プレースホルダーの利用が推奨される。

★3.DBの権限設定
WebアプリケーションでSELECT文で検索し表示する機能を考える。
この場合、表示するだけの機能が必要で更新の必要はない。
このように、必要な権限に応じてDBに接続するユーザの権限を適切に管理することで、
SQLインジェクションが実行された場合に、権限のレベルで無効とすることができる。

■SQLインジェクションのまとめ
最も安全な方法は静的プレースホルダーを利用することである。
ただし、既存のシステムを静的プレースホルダーへ改修することはコストがかかるため、
代替案として以下を考慮する。
1.文字列リテラルでは、記号等を適切にエスケープし、特殊文字として認識させない。
2.数値リテラルでは、数値以外を無効として、処理を行う。
