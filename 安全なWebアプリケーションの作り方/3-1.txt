■概要
Fiddlerをプロキシとして動作させ、http通信の中身を閲覧することで
データのやり取りを確認する。

クライアントからサーバへhttpの要求を出すことをリクエスト、返信データをレスポンスという。

■リクエストデータについて
リクエストメッセージはサーバに対する要求を示す。
一行目をリクエストラインという。
GET http://example.jp/31/31-001.php HTTP/1.1

リクエスト・メッセージの2行目以降はリクエストヘッダという。
値の名前：値　という形式でやり取りされる。
Accept: text/html, application/xhtml+xml, */*
Referer: http://example.jp/31/
Accept-Language: ja-JP
User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; Trident/7.0; rv:11.0) like Gecko
Accept-Encoding: gzip, deflate
Connection: Keep-Alive
DNT: 1
Host: example.jp

■レスポンスデータについて
レスポンスデータの一行目をステータスラインという。
HTTP/1.1 200 OK

二行目以降をレスポンスヘッダという。
値の名前：値　という形式でやり取りされる。
Date: Mon, 14 Mar 2016 04:19:22 GMT
Server: Apache/2.2.14 (Ubuntu)
X-Powered-By: PHP/5.3.2-1ubuntu4.2
Vary: Accept-Encoding
Content-Length: 20
Keep-Alive: timeout=15, max=99
Connection: Keep-Alive
Content-Type: text/html; charset=UTF-8

空行を挟み、レスポンスヘッダとボディで分けられる。
ヘッダは空行が続くまで継続する。

レスポンスボディはリクエストに対するレスポンスの内容(html等)が記載される。

■リクエストデータのPOSTについて
リクエストデータのPOSTにはボディと呼ばれる部分が存在する。
name=aaa&mail=aaa.mail&gender=%E5%A5%B3
パラメータは&で区切られ、特殊記号(全角?)や全角文字は%エンコードされる。
尚、スペースは+で表記される。

■Refererについて
リファラとはリクエストメッセージにつくヘッダで、リンク元のアドレス・要素が記載される。
この仕組を使うと、正常なリンクを辿って表示されているか否かが判別できる。

■GETとPOSTの使い分けについて
GETを利用する場合は以下の条件に合致する場合に限定すること。
1.GETメソッドは参照のみに用いる→更新系では使わない
2.GETメソッドは副作用がないことを期待する。→参照以外に利用されることがない、という意味。
　追加、更新、削除等にはGETを使ってはならない。
3.機密情報の送信にはPOSTを用いること。→GETだとURLに対して値を付与するのでセキュリティ上望ましくない。
　また、URLには上限があるのでパラメータが多くなるとGETでは対処できなくなる。

機密情報の扱い、また、追加・更新・削除で使ってはならない理由を以下に挙げる。
1.Referer経由で外部に情報が漏洩する。
2.アクセスログにパラメータがアドレスの一部として残るため、データが漏洩する。

つまり、以下の条件の場合はPOSTを用いる。
1.機密情報を含む情報である。
　→Referer経由、アクセスログ経由でデータが漏れる可能性があるため。
2.データの追加、更新、削除を含む処理であること。
　→Referer経由、アクセスログ経由でデータが漏れる可能性があるため。
3.データ量が多い場合。
　→GETだとURL上の長さ制限に引っかかる。そもそもデータがURL上に乗ることが望ましく無い。

■hiddenパラメータについて
httpは情報を保持できない。(データの引き回し等)そのため、データを保持するにはhiddenパラメータを使う。
FiddlerでBefore Requestsを選択すると、送信前のhiddenパラメータの書き換えが可能。
hiddenパラメータは自身で書き換えは可能だが、外部ユーザからの書き換えに対しては堅牢である。
まずは、書き換えられては困るデータはhiddenで検討し、必要性があればセッション変数、クッキー等を考慮する。(後述)
ログイン前のデータ保持にはセッション変数ではなくhiddenを推奨。(ID固定化攻撃を防ぐ為らしい)

■Basic認証について
Basic認証は初回アクセス時にサーバへリクエストを送信すると、レスポンスステータスとして401(認証が必要)コードが返却される。クライアントは401を受信した後、認証ダイアログを通じてサーバへリクエストを再度送付する。
認証IDとPassはAuthorizationパラメータとして送信されるため、デコードすることで内容を確認可能である。
IDとPassは：で区切られ、パラメータとして形を成す。
http通信は状態を保持しない。しかし、一度401レスポンスに対し認証が通るとクライアント(ブラウザ)が次回の401リクエストに対し自動的にIDとPassを記憶しており、記憶したIDとPassを自動的に送付する。このため、ユーザからは意識しないが認証が毎回裏側で行われている。

■クッキーとセッション管理
クッキー→サーバからユーザへの変数の保持に利用される。
クッキーが必要なサイトにリクエストを送信するとレスポンスのパラメータとして、Set-Cookieというクッキーの設定を示す内容が返却される。これによりクッキーがユーザ側のマシンに保存される。
同じサイトにアクセスする際、ブラウザは保存したクッキーの値を送り続ける。
クッキーには有効期間が設定されているが、有効期間がないものに対してはブラウザを終了するまでがクッキーの有効期間である。
ここではクッキーに設定された値をセッションIDとして利用する。
PHPSESSID=tj2i5rbo6lbkrslkdff3gk0jm3
クッキーは以下の特徴により利用方法を検討する。
・ユーザが自分で変更可能であるので機密情報を扱わない。
・クッキーに保存できるデータ量は限度があるので、大量のデータを保存しない。
クッキーに対してはセッションIDを保持し、データはサーバ側で保持する手法が一般的に用いられる。
クッキーは有効期限がある範囲内であると、毎回ブラウザからサーバへクッキーの値を送信する。
そのため、セッションIDをクッキーに保持する場合は以下に注意すること。
・第三者にセッションIDを推測されないこと。→ランダム性の確保。規則性が予測されないことが求められる。
　セッションIDの生成は自作で行わず、apache、tomcat等の一般的に利用されている乱数生成機能を用いること。
・第三者にセッションIDを強制されないこと。→クッキーの値が強制的に変更が加えられないことを担保する。
　認証前と後でセッションIDを生成し直すことで、セッションIDの強制を防止することができる。
・第三者にセッションIDが漏洩しないこと。
　→セッションIDが漏洩しやすい環境として公衆無線LAN環境が挙げられる。
　　また、有効な手段としてSSLを行うこと。
　　
■クッキーの属性について
クッキーを生成するときにオプションを指定可能。
クッキーはデフォルトでクッキーを生成したサイトにのみ送信されるように生成される。
クッキーのオプションにより、送信するドメイン指定が可能となる。P51の図参照。
★domain属性
Domain属性にdomain=example.jpと指定した場合は、以下のサイトのように配布状況が定義される。
a.example.jp OK
b.example.jp OK
a.example.com NG
便利な反面、domain属性を指定してしまうと、同一ドメインに対してクッキーを送付してしまう為、セッションIDの漏洩の原因となる場合がある。そのため、通常はdomain指定でクッキーを作成することはない。

★セキュア属性
セキュア属性を指定すると、sslで通信する場合にのみクッキーを送信する。
通常、クッキー生成時に指定しない場合、http/httpsにかかわらずクッキーを送信する。

★httponly属性
javascriptによるクッキーに保存されたセッションIDの読み出しを防止する。
